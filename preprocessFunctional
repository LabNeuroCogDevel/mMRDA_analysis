#!/bin/bash

function printHelp() {

cat <<EndOfHelp
-----------------------------------
preprocessFunctional is a script to preprocess an fMRI EPI scan.

Three files are required for this preprocessing script:
  1) 4d functionals file (-4d command line parameter). Alternative: -dicom
  2) betted mprage scan (-mprage_bet command line parameter)
  3) mprage-to-standard-space warp coefficients (-warpcoef command line parameter)

Command line options:
  -4d: The 4d file containing unprocessed functional volumes for a single subject. Required.
  -bet_frac: fractional intensity threshold for skull-stripping mean functional (used in func-to-struc warp). Default 0.3.
  -cleanup: Deletes all files used in preprocessing that are unlikely to be needed for analysis
  -constrain_to_template: Constrain brain voxels to the corresponding standard template (e.g., MNI). y or n. Default: y.
  -delete_dicom: if converting dicom to nifti, whether delete or archive DICOM files. If not
        passed, user will be prompted for action. Options are:
        -delete_dicom no. (leaves DICOM untouched)
        -delete_dicom yes. (deletes DICOM files)
        -delete_dicom archive. (compresses files into archive file): functional_dicom.tar.gz.
  -deoblique_all: Deoblique all functional datasets (3dWarp -deoblique) after all preprocessing complete: y or n. Default is n.
  -despike: Whether to interpolate intensity spikes using 3dDespike. Occurs early in pipeline: y or n. Default is n.
  -despike_thresh: Cut thresholds for 3dDespike (how much to despike). Default to 2.5 and 4.0.
  -dicom: The file pattern to match all dicom files to be converted to nifti. Must be in quotes.
        Example: -dicom "MR*" (This parameter is an alternative to passing the 4d nifti file using -4d)
  -fm_phase: gre field map phase image
  -fm_magnitude: field map magnitude image (mag2.nii.gz)
  -fm_cfg: configuration file for handling fieldmap (TEs, echo spaceing, etc.)
  -func_struc_dof: The number of degrees of freedom to be used when co-registering the mean subject
        functional (EPI) scan to the subject structural (T1) scan. Defaults to bbr (boundary based registration).
        -func_struc_dof bbr. BBR segments the T1 to create a white matter boundary mask, which is used to help align EPI and T1.
        -func_struc_dof 6.  Rotation x, y, z; Translation x, y, z.
        -func_struc_dof 7.  Rotation x, y, z; Translation x, y, z; Global scaling.
        -func_struc_dof 12. Rotation x, y, z; Translation x, y, z; Scaling x, y, z; Skewing x, y, z.
  -help: Print command help.
  -hp_filter: high-pass filtering frequency (in volumes). Anything faster than this value will be passed. Default is 80.
  -log: Name for log file that documents each command that is run. Default: preprocessFunctional.log
  -mc_first: run motion correction before slice timing correction, regardless of slice acquisition order.
  -mc_program: what program to use for motion correction. Options: mcflirt, 3dvolreg. Default: 3dvolreg.
  -motion_sinc: Complete a 4th stage optimization of motion correction using sinc interpolation (slower but better): y or n. Default y.
  -mprage_bet: The betted structural scan for this participant. Required.
  -no_warp: Maintain native space and resolution of input image. Do not warp to a template.
  -no_st: Do not perform slice timing correction.
  -ref_vol: Reference volume to be used in motion correction. Will default to mean volume if not passed.
  -rescaling_method: The method used to normalize voxel intensities. Options are:
        -rescaling_method 10000_globalmedian (FSL's default, rescale the 4d file by a single quantity: 10000/[global median])
        -rescaling_method 100_voxelmean (Rescale each voxel by 100/[voxel 4d mean]. In principle, approximates % change)
  -custom_slice_times: For use with 4d slice timing + motion correction. 
        A csv file containing the times (in seconds summing to TR) of each slice (bottom to top).
        Example: -custom_slice_times "../SPECCMBSliceTimes.csv"
  -slice_acquisition: The order in which slices were acquired.
        -slice_acquisition seqasc. Sequential ascending (bottom-up)
        -slice_acquisition seqdesc. Sequential descending (top-down)
        -slice_acquisition interleaved. Interleaved 1,3,5... 2,4,6...
  -4d_slice_motion: use 4d simultaneous slice-timing motion correction algorithm (calls sliceMotion4D)
  -smoothing_kernel: The size of gaussian smoothing kernel in mm. Default: 5
  -smoother: The smoothing approach to use. Defaults to "susan" (tries to normalize intensities without
        blurring). Alternative is "gaussian", which is regular smoothing.
  -startover: rather than skipping preprocessing stages that have been
        completed, re-run all processing stages, overwriting any existing files.
  -st_first: run slice timing correction first, regardless of slice acquisition order.
        By default, slice timing is run before motion correction for interleaved sequences, but after
        motion correction for sequential acquisition.
  -template_brain: Which standard template brain to use. Default: MNI_3mm. Must match template from mprage normalization. Options:
        -template_brain MNI_3mm (MNI152 brain, 3mm isotropic voxels, template from MNI Fonov et al. 2009)
        -template_brain MNI_FSL_3mm (MNI152 brain, 3mm isotropic voxels, template from FSL standard)
        -template_brain SPM_2mm (MNI brain from spm8 canonical template)
        -template_brain Tal_3mm (Talairach brain, 3mm isotropic voxels. Brain built by resampling MNI template in Tal space)
  -threshold: The method to use for thresholding/masking low intensity voxels. Options are:
        -threshold 98_2 (FSL's default, 2nd %ile + (98th %ile - 2nd %ile)/10
        -threshold 10 (mask any voxels below the 10th percentile)
  -tr: TR duration in seconds.
  -trio_tim: only relevant for -4d input. If set, slice timing correction will check for interleaved
        order and odd vs. even number of slices. If even, will create and use --ocustom file 2,4,6...1,3,5...
  -warpcoef: The warp coefficients used to transform the structural scan to standard space. Required.
  -warp_interpolation: The intepolation method used to warp functional data to the mprage and to the standard space (e.g., MNI). Default: spline.
        -warp_interpolation spline. Use cubic spline interpolation to apply warp coefficients. Faster than sinc and slightly more blurry, but more robust to mask. (Default)
        -warp_interpolation sinc. Provides higher quality non-blurry resampling relative to trilinear, but is slower. N.B. Only works well when the subject's
               functional mask is precise and contains only brain voxels. Otherwise, sinc is prone to stretching the warp strangely.
        -warp_interpolation trilinear. Faster method, but somewhat blurry.

The major steps in the processing pipeline are, in order:
  1)   Intensity despiking (optional) - d
  2)   Field map unwarping (optional) - u
  3)   Slice timing correction - t
  4)   Motion correction - m
  5)   Skull stripping - k
  6)   Co-registration and warping to standard space - w
  7)   Smoothing - s
  8)   High-pass filtering - f
  9)   Intensity normalization - n

Note that if the slice acquisition order is sequential, then motion correction is applied before slice timing correction.

Characters are prepended as a prefix to the 4d filename, such that the final processed file will have a
prefix such as nfswkmtd, indicating the sequence of processing steps, from right to left.

N.B. For the warping to work properly, you must use preprocessMprage for the mprage scan, which uses the same template set.

Example call:
  preprocessFunctional -4d 10802func.nii.gz -mprage_bet 10802mprage.nii.gz -warpcoef mprage_warpcoef.nii.gz -slice_acquisition seqasc \
      -tr 2 -smoothing_kernel 6 -cleanup

-----------------------------------
EndOfHelp

}

#Written: 5/18/2010
#Last updated: 03/10/2014
#
#Changelog:
#03/10/2014
# - change default high-pass filter cutoff to 80 volumes. So if user does not specify, it should be quite gentle.
# - add MNI_2.3mm template target for MB 2.3mm data.
#02/13/2014
# - added -mc_program to allow user to choose between mcflirt and 3dvolreg. 3dvolreg is now default because of evidence (Beall) that mcflirt badly estimates rotations.
#12/12/2013
# - added -custom_slice_times file to allow a csv-formatted file of slice times to be passed through to sliceMotion4d --slice_times.
#11/11/2013
# - no_st option was not running motion correction in some cases. Re-factored to be more explicit.
#02/28/2013
# - only re-run FAST on mprage for BBR registration if fast segmentation does not exist.
#10/04/2012
# - default to BBR (boundary-based registration) for epi-to-T1 coregistration. BBR is part of FSL 5.0 that improves this coregistration considerably. Not yet coupled with fieldmap.
#09/24/2012
# - provide -no_smooth option.
# - move .preprocessfunctional_incomplete section below command line parsing so that it doesn't fire on an empty call.
#08/15/2012
# - changed default -bet_frac to 0.3 to be consistent with FEAT. Less severe skull strip.
# - revert -func_struc_dof to 7, not 12. This is used for functional-to-structural registration, which should only involve translation, rotation, and scaling.
#08/10/2012
# - add .preprocessfunctional_complete with command and date $datefmt
#08/07/2012
# - Provide -no_st option to skip slice timing correction. See here: https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1207&L=FSL&P=R95699
# - Provide -mc_first option to perform motion correction first.
#08/02/2012
# - make skullstrip and field map unwarp functions
# - fm_cfg for FM unwarping
#07/12/2012
# - Provide -no_warp option to maintain native space.
# - Provide -constrain_to_template option, which defaults to yes. This constrains functional voxels to the standard space anatomical (eliminates extra-brain activation).
#06/07/2012
# - Only retain voxels with non-zero values at all timepoints. Extents mask created before smoothing, applied after.
#06/04/2012
# - Provide option to use SPM8 MNI template.
#05/26/2012
# - Retain rms motion files from mcflirt.
# - Provide -st_first option for those who want to run slice timing first.
#04/10/2012
# - Change skull-stripping and thresholding to apply BET + low intensity + dilate mask to pre-BET data so that BET does not rule edge voxels (follows FEAT).
#04/09/2012
# - incorporate fieldmap unwarping.
#02/06/2012
# - changed default warp interpolation to spline. Sinc was generating too many strange artifacts when functional mask didn't precisely match the boundaries of subject brain.
#01/27/2012
# - small fixes to use of --ocustom, added checks for odd/even with -4d input and added -trio_tim flag
#01/18/2012
# - add --ocustom to acquisitionString for interleaved TrioTim with even num total slices -- Will
#12/5/2011
# - added -log parameter to log the exact preprocessing commands used
#11/17/2011
# - added option to run 3dDespike on functionals prior to motion or slice timing correction.
#10/27/2011
# - put back in 3dresample to orient to LPI. With some of Kirsten's data, warp was failing due to some orientation problem.
#10/18/2011
# - removed 3dresample command to orient original functional to LPI. Bug in AFNI that was flipping storage but not header.
# - Added -f to gzip to overwrite old file.
#9/27/2011
# - Switched dicom conversion to Dimon
# - Default to MNI nonlinear template from Vladimir Fonov (added MNI_FSL_3mm option)
# - Use improved Talairach template (@auto_tlrc approach)
# - Ensure that images are oriented to LPI for MNI space
# - Restrict applywarp to brain voxels (problems with sinc smudging the image when not masked)
# - Use wktm mask based on thresholding step as final mask for subject. (problems with Susan + sinc creating tiny, weird artifacts ringing at the outside of brain)
# - Auto-detect slice acquisition order and TR from DICOM header. Notify user of discrepancies.
# - Create symbolic link to standard space template within subject directory. Documents the template used and makes it easier to view functional data against structural backdrop.
# - Default motion correction sinc interpolation ON. Makes things run slower (~20 min/subject), but can be turned off if user needs results quickly.
# - Create symbolic link to final mask for subject: subject_mask.nii.gz.
# - Remove default TR. Detected from DICOM or must be passed by user.
#6/16/2011
# - SO commented out a delete file command for an file that was never created
#6/13/2011
# - Based on DM's initiative, implemented option for deobliquing datasets as final preprocessing step. For visualization convenience only.
#5/11/2011
# - Now appropriately varies the order of slice timing correction and motion correction depending on sequential vs. ascending slice order
#4/28/2011
# - updated code in the 'startover'section. was missing this: deleteFile ".thresholding_complete" (DM)
# - added a step to remove any previous file left over from dcm2nii before running it (DM)
#4/26/2011:
# - updated code in the 'check for existence of required files' to allow symbolic links to mprage_bet and mprage_warpcoef files (DM)
#3/20/2011:
# - Added final stage mean functional and corresponding mask to be used in GLM
#3/11/2011:
# - Added option for slice acquisition order for proper slice timing correction.
#3/10/2011:
# - Switched default template brain to MNI.
#3/8/2011:
# - Changed rm command to include -f to handle files that lack write permission.
# - Added -motion_sinc parameter for final stage sinc interpolation during motion correction.
# - Added -template_brain parameter to allow choice of MNI vs. Tal.
#11/8/2010:
# - Added -bet_frac parameter for fractional intensity threshold. Default 0.4.
#11/5/2010:
# - Changed default DOF for functional-structural coregistration to 12.
# - Added -func_struc_dof option for setting functional-structural DOF.
#9/2/2010:
# - Changed HP Filter to default of 40 TRs, not 20. 20 seems way too short and 
#     is likely to filter some slower task-related effects. FSL defaults to
#     100s (~66 TRs at TR=1.5), SPM default to 128s. So even 40 may be too fast.
# - Improved checks for median calculation if thresholding complete
#8/9/2010:
# - added rescaling_method parameter to support grand mean rescaling
# - fixed thresholding_complete logic for cases where thresholding complete, but need median_intensity
#7/26/2010:
# - Added dicom processing options
#6/28/2010:
# - updated to improve filename handling with prepending of processing steps.
# - removed robert compatibility settings (forked to preprocessFunctional_Old)

#TODO: 
# - Switch high pass filtering to seconds, not TRs and use bc to calculate #TRs.

function deleteFile() {
    #delete a file, if it exists
    if [ -f "$1" ]; then
	rm -f "$1"
    fi
}

#rel is shorthand for "run, echo, log"
function rel() {
    #function that runs, echos to terminal, and logs to file an arbitrary command
    cmd="${1}"
    comment=0
    if [[ -n "${2}" && ${2} = c ]]; then
	comment=1
    fi
    
    #echo to screen
    echo ${cmd}

    #run command   
    if [ $comment -eq 0 ]; then
	eval ${cmd}
    fi
    
    if [ -n "${logFile}" ]; then
	if [ $comment -eq 1 ]; then
	    cmd="## ${cmd}"
	fi
	echo "${cmd}" >> "${logFile}"
    fi
}


set -e #exit if any error occurs (stop processing)

export FSLOUTPUTTYPE='NIFTI_GZ'

#initialize defaults
funcFile=
smoothing_kernel="5"
betFrac=0.3 #default fractional intensity threshold
cleanup=0
constrainToTemplate="y"
deoblique_all="n"
despike="n"
despikeThresh="2.5 4.0"
delDicom=
detectTrioTim=0
dicomPattern=
dte=
fm_phase=
fm_magnitude=
fm_cfg=
funcStructFlirtDOF="bbr" #boundary-based registration in FSL 5.0+
funcWarpInterp="spline"
hpFilter=80
logFile="preprocessFunctional.log"
mc_first=0
mc_program="3dvolreg"
motionSinc="y"
no_st=0
no_smooth=0
no_warp=0
ref_vol=  #don't set a motion correction reference volume by default
rescalingMethod="10000_globalmedian" #scale whole brain 4D by single constant to normalize median to 10000.
sliceAcquisition= #never assume slice acquistion order. Force definition or use auto-detect from DICOM.
sliceMotion4D=0
sliceTimesFile=
smoother="susan"
st_first=0
thresholdMethod="98_2"
tr= #never assume a TR. Force definition or use auto-detect from DICOM.
templateBrain="$HOME/standard/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_3mm" #default to new 2009 MNI

#figure out file extension for FSL programs
if [ -z $FSLOUTPUTTYPE ]; then
    export FSLOUTPUTTYPE=NIFTI_GZ
fi

if [ $FSLOUTPUTTYPE = NIFTI_GZ ]; then
    ext=".nii.gz"
elif [ $FSLOUTPUTTYPE = NIFTI ]; then
    ext=".nii"
else
    echo "Not setup to handle FSLOUTPUTTYPE: $FSLOUTPUTTYPE."
    exit 1
fi

#if no parameters are passed in, then print help and exit.
if [ $# -eq 0 ]; then
    printHelp
    exit 0
fi

#process command line parameters
while [ _$1 != _ ] ; do
    if [[ $1 = -4d || $1 = -4D ]] ; then
	funcFile="${2}"
	funcNifti="${funcFile}" #retains file extension
	shift 2
    elif [ $1 = -bet_frac ]; then
	betFrac="${2}"
	shift 2
    elif [ $1 = -cleanup ]; then
	cleanup=1
	shift 1
    elif [ $1 = -custom_slice_times ]; then
	sliceTimesFile="$2"
	sliceMotion4D=1 #for now, this option is only relevant for sliceMotion4d correction
	shift 2
    elif [ $1 = -constrain_to_template ]; then
	if [[ $2 = [NnYy] ]]; then
	    constrainToTemplate="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -constrain_to_template parameter: ${2}.\n  Options are: y or n."
	    exit 1
	fi
    elif [ $1 = -delete_dicom ]; then
	if [[ $2 = "delete" || $2 = "yes" || $2 = "no" || $2 = "archive" ]]; then
	    delDicom="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -delete_dicom: ${2}.\n  Options are: -delete_dicom delete yes no archive."
	    exit 1
	fi
    elif [ $1 = -deoblique_all ]; then
	if [[ $2 = [NnYy] ]]; then
	    deoblique_all="${2}"
	    shift 2
	else
	    echo -e "Unrecognized deoblique_all parameter: ${2}.\n  Options are: y or n."
	    exit 1
	fi
    elif [ $1 = -despike ]; then
	if [[ $2 = [NnYy] ]]; then
	    despike="${2}"
	    shift 2
	else
	    echo -e "Unrecognized despike parameter: ${2}.\n  Options are: y or n."
	    exit 1
	fi
    elif [ $1 = -despike_thresh ]; then
	despikeThresh="$2 $3"
	shift 3
    elif [ $1 = -dicom ]; then
	dicomPattern="${2}"
	shift 2
    elif [ $1 = -fm_phase ]; then
	fm_phase="${2}"
	shift 2
    elif [ $1 = -fm_magnitude ]; then
	fm_magnitude="${2}"
	shift 2
    elif [ $1 = -fm_cfg ]; then
	fm_cfg="${2}"
	shift 2
    elif [ $1 = -func_struc_dof ]; then
	if [[ $2 = "bbr" || $2 = "6" || $2 = "7" || $2 = "12" ]]; then
	    funcStructFlirtDOF="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -func_struc_dof: ${2}.\n  Options are: -func_struc_dof bbr, 6, 7, 12."
	    exit 1
	fi
    elif [ $1 = -help ]; then	
	printHelp
	exit 0
    elif [ $1 = -hp_filter ]; then
	hpFilter="${2}"
	shift 2
    elif [ $1 = -log ]; then
	logFile="${2}"
	shift 2
    elif [ $1 = -mc_first ]; then
	mc_first=1
	shift 1
    elif [ $1 = -mc_program ]; then
	if [[ $2 = "3dvolreg" || $2 = "mcflirt" ]]; then
	    mc_program="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -mc_program: ${2}.\n  Options are: -mc_program 3dvolreg, mcflirt."
	    exit 1
	fi
    elif [ $1 = -motion_sinc ]; then
	if [[ $2 = [NnYy] ]]; then
	    motionSinc="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -motion_sinc parameter: ${2}.\n  Options are: y or n."
	    exit 1
	fi
    elif [ $1 = -mprage_bet ]; then
	mprageBet="${2}"
	shift 2
    elif [ $1 = -no_smooth ]; then
	no_smooth=1
	shift 1
    elif [ $1 = -no_st ]; then
	no_st=1
	shift 1
    elif [ $1 = -no_warp ]; then
	no_warp=1
	shift 1
    elif [ $1 = -ref_vol ] ; then
        ref_vol="${2}"
        shift 2
    elif [ $1 = -rescaling_method ]; then
	if [[ $2 = "10000_globalmedian" || $2 = "100_voxelmean" ]]; then
	    rescalingMethod="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -rescaling_method: ${2}.\n  Options are: -rescaling_method 10000_globalmedian or -rescaling_method 100_voxelmean"
	    exit 1
	fi
    elif [ $1 = -slice_acquisition ]; then
	if [[ $2 = "interleaved" || $2 = "seqasc" || $2 = "seqdesc" ]]; then
	    sliceAcquisition="${2}"
	    shift 2
	else
	    echo "Slice acquisition setting not recognized. Options are: seqdesc, seqasc, and interleaved"
	    exit 1
	fi
    elif [ $1 = -4d_slice_motion ]; then
	sliceMotion4D=1
	shift 1
    elif [ $1 = -smoother ]; then
	smoother="${2}"
	shift 2
    elif [ $1 = -startover ]; then
	echo -e "\nStarting over...\n\nRe-running all preprocessing steps\n"
	deleteFile ".motion_plots_complete"
	deleteFile ".slice_timing_complete"
	deleteFile ".motion_correction_complete"
	deleteFile ".skull_strip_complete"
	deleteFile ".warp_complete"
	deleteFile ".smoothing_complete"
	deleteFile ".temporal_filtering_complete"
	deleteFile ".rescaling_complete"
	deleteFile ".thresholding_complete"
	deleteFile ".despike_complete"
	deleteFile ".unwarp_complete"
	deleteFile ".preprocessfunctional_complete"
	shift 1
    elif [ $1 = -smoothing_kernel ] ; then
        smoothing_kernel="${2}"
	smoothing_suffix="_${smoothing_kernel}"
        shift 2
    elif [ $1 = -st_first ]; then
	st_first=1
	shift 1
    elif [ $1 = -template_brain ]; then
	case $2 in
	    Tal_3mm) templateBrain="$HOME/standard/talairach_fsl_mni152/TalFSL_MNI152_T1_3mm_brain" ;;
	    MNI_FSL_3mm) templateBrain="$HOME/standard/fsl_mni152/MNI152_T1_3mm_brain" ;;
	    MNI_3mm) templateBrain="$HOME/standard/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_3mm" ;;
	    MNI_2.3mm) templateBrain="$HOME/standard/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_2.3mm" ;;
	    MNI_2mm) templateBrain="$HOME/standard/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_2mm" ;;
	    SPM_2mm) templateBrain="$HOME/standard/spm8_mni/T1_brain" ;;
	    *) echo -e "Reference brain -template_brain ${2} not recognized. Options are MNI_3mm, MNI_FSL_3mm, SPM_2mm, and Tal_3mm."; exit 1 ;;
	esac
	shift 2
    elif [ $1 = -threshold ]; then
	if [[ $2 = "98_2" || $2 = "10" ]]; then
	    thresholdMethod="${2}"
	    shift 2
	else
	    echo -e "Unrecognized thresholding parameter: ${2}.\n  Options are: 98_2 or 10."
	    exit 1
	fi
    elif [ $1 = -tr ]; then
	tr="${2}"
        shift 2
    elif [ $1 = -trio_tim ]; then
	detectTrioTim=1
	shift 1
    elif [ $1 = -warpcoef ]; then
	warpCoef="${2}"
	shift 2
    elif [ $1 = -warp_interpolation ]; then
	if [[ $2 = "sinc" || $2 = "trilinear" || $2 = "spline" ]]; then
	    funcWarpInterp="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -warp_interpolation parameter: ${2}.\n  Options are: sinc, spline, or trilinear."
	    exit 1
	fi
    else
	printHelp
	echo -e "----------------\n\n"
	echo "Unrecognized command line parameter: ${1}"
	exit 1
    fi
done

datefmt='+%F+%I:%M'
#grab command, arguments, script version (date), and start time
thiscommandinfo="$0 $@ \n# preprocessFunctional v$(perl -ne 'print $1 if /^#Last updated: (.*)/' $0) \n# Run started $(date $datefmt) "
dotfile=.preprocessfunctional

# write to an incompelete file (later to be changed to complete if process finishes)
echo -e "$thiscommandinfo " > ${dotfile}_incomplete


if [ -n "${logFile}" ]; then
    if [ -f "${logFile}" ]; then
	rm -f "${logFile}"
    fi
    echo "#!/bin/bash" > "${logFile}"
    echo "## Log of preprocessFunctional commands" >> "${logFile}"
    echo -e "## Call: $thiscommandinfo" >> "${logFile}"
fi

################################################################################
# Setup
################################################################################

#The smoothing kernel parameter is expected to be the full width at half
#maximum (FWHM) value (in mm). FWHM refers to the width of the Gaussian shape
#on the x-axis at half of the maximum y value
#(see http://imaging.mrc-cbu.cam.ac.uk/imaging/PrinciplesSmoothing).
#It is common to conceptualize Gaussian curves in terms of their standard
#deviation (sigma). Sigma is related to FWHM by the following equation:
#FHWM=sigma * sqrt(8*log(2))
#Hence, because FSL expects our smoothing specification to be a sigma,
#we divide the FWHM value provided by $smoothing_kernel by 2.355 (approximately
#8*log(2).

sigma=$( echo "scale=5; $smoothing_kernel/2.355" | bc )
#echo "sigma is: $sigma"

#whether to use a 4-stage coregistration for mcflirt with sinc interpolation for resampling
if [[ ${motionSinc} = [Yy] ]]; then
    mcflirtSinc="-stages 4 -sinc_final"
else
    mcflirtSinc=
fi

#check that slice acquisition order and TR was specified or detected in case of 4d input
if [ -n "$funcFile" ]; then
    if [ -f .detect_sliceorder ]; then
	if [ -n "$sliceAcquisition" ]; then
	    rel "Ignoring user setting for slice acquisition: ${sliceAcquisition} because of auto-detected order in .detect_sliceorder." c
	fi

	sliceAcquisition=$( cat .detect_sliceorder )
    fi

    if [[ -z $sliceAcquisition && $no_st -eq 0 ]]; then #only enforce provision of slice acquisition order if slice timing in pipeline.
	echo -e "Slice acquisition order was not specified and not detected.\nPass using the -slice_acquisition parameter.\nExiting.\n"
	exit 1
    fi

    if [ -f .detect_tr ]; then
	if [ -n "$tr" ]; then
	    rel "Ignoring user setting for TR: ${tr} because of auto-detected TR in .detect_tr." c
	fi  

	tr=$( cat .detect_tr )
    fi

    if [ -z $tr ]; then
	echo -e "TR was not specified and not detected.\nPass using the -tr parameter.\nExiting.\n"
	exit 1
    fi

    #check number of slices
    #if DICOMs used, num slices will be picked up by section below
    detectSliceNum=$( fslhd ${funcFile}  | grep '^dim3' | perl -pe 's/dim3\s+(\d+)/\1/' )

fi

#check for existence of required files
#mprageBet and warpCoef only required if warping to a standard template. Thus, don't require for -no_warp runs.
if [ $no_warp -eq 0 ]; then
    if [ -z $mprageBet ]; then
	echo -e "Betted mprage file parameter not provided.\nPass using the -mprage_bet parameter.\nExiting.\n"
	exit 1
    elif [[ ! -f $mprageBet ]] && [[ ! -h ${mprageBet} ]]; then
	echo -e "Betted mprage file: $mprageBet does not exist.\nExiting.\n"
	exit 1
    fi

    if [ -z $warpCoef ]; then
	echo -e "Structural to standard space warp coefficients file (from FNIRT) not provided.\nPass using the -warpcoef parameter.\nExiting.\n"
	exit 1
    elif [[ ! -f $warpCoef ]] && [[ ! -h ${warpCoef} ]]; then
	echo "Structural to standard space warp coefficients file does not exist.\nFile specified: $warpCoef.\nExiting.\n"
	exit 1
    fi
fi

#check file extensions to see if file was passed in with nii or nii.gz extension
#could be made more efficient by combining nii and nii.gz section
if [ -z $funcFile ]; then

    #if 4d file not passed, check for dicom pattern
    #need dicomPattern in quotes to avoid expansion
    if [ -z "$dicomPattern" ]; then
	echo -e "No 4d file provided to script. This file is required.\nPass using the -4d parameter.\n"
	echo -e "Alternatively, pass a dicom file pattern, such as -dicom \"MR*\"\nExiting.\n"
	exit 1
    else
	#process dicom files first
        #check whether files exist
	numFiles=$( ls $dicomPattern | wc -l )
	if [ $numFiles -eq 0 ]; then
	    echo "No DICOM files found using pattern: $dicomPattern. If you have already converted DICOM to NIFTI and want to skip this step, pass in the 4d functionals file using the -4d parameter. Example: preprocessFunctional -4d 10802_func.nii.gz"
	    exit 1
	fi

	funcFile="functional" #base name for preprocessing steps below
	funcNifti="functional.nii.gz"

	#look for TR and slice acquisition order in Dicom
	firstDicom=$( find . -iname "${dicomPattern}" -type f | head -1 )
	dicomHdr=$( dicom_hdr -sexinfo "${firstDicom}" )
	detectTR=$( echo "${dicomHdr}" | grep "0018 0080.*ACQ Repetition Time" | perl -pe 's/.*ACQ Repetition Time\/\/(\d+)$/\1/' )
	detectTR=$( echo "scale=3; ${detectTR}/1000" | bc ) #convert to seconds from milliseconds
	detectSliceOrder=$( echo "${dicomHdr}" | grep "sSliceArray.ucMode" | perl -pe 's/sSliceArray.ucMode\s+=\s+(\dx\d)$/\1/' )

	if [ "${detectSliceOrder}" = "0x1" ]; then
	    detectSliceOrder="seqasc"
	elif [ "${detectSliceOrder}" = "0x2" ]; then
	    detectSliceOrder="seqdesc"
	elif [ "${detectSliceOrder}" = "0x4" ]; then
	    detectSliceOrder="interleaved"
            #used to test need for ocustom switch in slicetimer
            detectTrioTim=$(    echo "${dicomHdr}" | perl -ne 'print "1" if /TrioTim/' )
            detectSliceNum=$(   echo "${dicomHdr}" | perl -ne 'print $1  if /sSliceArray.lSize\W+=\W?(\d+)/' )
	fi

	rel "Auto-detecting TR and slice acquisition order from DICOM header: ${firstDicom}" c
	rel "  Detected TR: ${detectTR}s" c
	rel "  Detected Slice Order: ${detectSliceOrder}" c
	rel "  Number of slices: ${detectSliceNum}" c
	rel "  If this is incorrect, please exit the script now by pressing Ctrl-C" c

	sleep 3

	#check auto-detect against user specification
	if [ -n "${tr}" ]; then
	    trEquiv=$( echo "${tr} == ${detectTR}" | bc )	    
	    if [ ${trEquiv} -eq 0 ]; then
		echo "Specified TR: ${tr} does not match detected TR: ${detectTR}"
		echo "Exiting script. Please resolve discrepancy."
		exit 1
	    fi
	fi

	if [ -n "${sliceAcquisition}" ] && [ "${sliceAcquisition}" != "${detectSliceOrder}" ]; then
	    echo "Specified slice order: ${sliceAcquisition} does not match detected slice order: ${detectSliceOrder}"
	    echo "Exiting script. Please resolve discrepancy."
	    exit 1
	fi

	#set run parameters based on auto-detected settings
	tr=${detectTR}
	sliceAcquisition=${detectSliceOrder}

	echo "${detectTR}" > .detect_tr
	echo "${detectSliceOrder}" > .detect_sliceorder
	
	#remove functional.nii if it exists so that Dimon doesn't bomb out
	deleteFile functional.nii
	deleteFile functional.nii.gz

	rel "Dimon \
	    -infile_pattern \"${dicomPattern}\" \
	    -GERT_Reco \
	    -quit \
	    -dicom_org \
	    -sort_by_acq_time \
	    -gert_write_as_nifti \
	    -gert_create_dataset \
	    -gert_to3d_prefix functional"

	rm -f dimon.files*
	rm -f GERT_Reco_dicom*

        #if afnirc has compressor on, then above will already generate nii.gz
	if [ -f functional.nii ]; then
	    rel "gzip -f functional.nii" #use -f to force overwrite in case where functional.nii.gz exists, but we want to replace it.
	fi

	#default to LPI
	#hopefully the 3dresample bug is fixed:
	#http://afni.nimh.nih.gov/afni/community/board/read.php?f=1&i=39923&t=39923
	rel "3dresample -overwrite -orient LPI -prefix \"functional.nii.gz\" -inset \"functional.nii.gz\""

        #Ask user what to do with original DICOM files unless passed on command line
	if [ -z $delDicom ]; then
	    until [[ "$delDicom" = [AaNnYy] ]]; do
		read -sn1 -p "Delete or archive original DICOM files? (y/n/a)" delDicom
	    done
	else
	    [ "$delDicom" = "delete" ] && delDicom="y" #yes and delete are the same
	    delDicom=${delDicom:0:1} #retain only the first character
	fi

	case ${delDicom} in
	    y|Y) echo -e "\nDeleting DICOM files"; rm -f ${dicomPattern} ;;
	    n|N) echo -e "\nKeeping DICOM files" ;;
	    a|A) echo -e "\nArchiving DICOM files (functional_dicom.tar.gz)"; tar czf functional_dicom.tar.gz ${dicomPattern} && rm -f ${dicomPattern} ;;
	esac
	sleep 1

    fi
elif [ ${funcFile:(-7)} = ".nii.gz" ]; then
    if [ ! -f ${funcFile} ]; then
	echo -e "Raw functional 4D file: $funcFile does not exist.\nPass in as -4d parameter. Exiting.\n"
	exit 1
    else
	#strip off the suffix for FSL processing and makes filenames easier to build.
	lenFile=${#funcFile}
	lenSub=$( expr $lenFile - 7 )
	funcFile=${funcFile:0:$lenSub}
    fi
elif [ ${funcFile:(-4)} = ".nii" ]; then
    if [ ! -f ${funcFile} ]; then
	echo -e "Raw functional 4D file: $funcFile does not exist.\nPass in as -4d parameter. Exiting.\n"
	exit 1
    else
	#strip off the suffix for FSL processing
	lenFile=${#funcFile}
	lenSub=$( expr $lenFile - 4 )
	funcFile=${funcFile:0:$lenSub}
    fi
else
    #passed in parameter does not have nii or nii.gz extension. Need to test for file
    if [[ ! -f "${funcFile}.nii" && ! -f "${funcFile}.nii.gz" ]]; then
	echo -e "Raw functional 4d file: $funcFile does not exist.\nAttempted to look for ${funcFile}.nii and ${funcFile}.nii.gz to no avail.\nExiting.\n"
	exit 1
    fi
fi


prefix= #tracks file prefix indicating which processing steps have been performed

numVols=$( fslhd ${funcFile} | grep '^dim4' | perl -pe 's/dim4\s+(\d+)/\1/' )
middleVol=$( echo "$numVols/2" | bc )

#1) MOTION PLOTS
#When motion correction precedes slice timing, the pipeline is somewhat inefficient because motion correction
#is run twice on the same data. 
if [ ! -f ".motion_plots_complete" ]; then
    #####
    #create rotation, translation, and displacement plots of subject motion
    #If ref_vol is not provided, then mcflirt defaults to middle volume.

    rel "1. Creating subject motion plots" c
    #include -mats to obtain affine matrices, which are used for fieldmap + motion correction
    #N.B. mcflirt deprecated because of evidence that it poorly estimates rotations (Beall)

    if [ -z $ref_vol ]; then
	coreg_target="$middleVol"
    else
	coreg_target="$ref_vol"
    fi

    if [ $mc_program = "mcflirt" ]; then	
	rel "mcflirt -in \"$funcFile\" -o mcplots -plots -rmsabs -rmsrel -mats -refvol ${coreg_target}" # middle volume

	#displacement plot
	rel "fsl_tsplot -i mcplots_abs.rms,mcplots_rel.rms -t 'MCFLIRT estimated mean displacement (mm)' -u 1 -w 800 -h 300 -a absolute,relative -o disp.png"

    elif [ $mc_program = "3dvolreg" ]; then
	rel "3dvolreg -Fourier -twopass -base ${coreg_target} -zpad 4 -maxdisp1D maxdisp.1D -1Dfile 3dvolreg.par -prefix mcplots.nii.gz \"$funcNifti\""
	#convert to match mcflirt: Rx Ry Rz (radians) Tx Ty Tz (mm)
	rel "Note that mcplots.par contains 3dvolreg motion parameters reformatted to match mcflirt column order: Rx, Ry, Rz, (radians) Tx, Ty, Tz." c
	rel  "awk "\''{print $2*(3.141593/180),$3*(3.141593/180),$1*(3.141593/180),$5,$6,$4}'\'" 3dvolreg.par > mcplots.par"
    fi

    #rotations plot
    rel "fsl_tsplot -i mcplots.par -t '$mc_program estimated rotations (radians)' -u 1 --start=1 --finish=3 -a x,y,z -w 800 -h 300 -o rot.png"

    #translations plot
    rel "fsl_tsplot -i mcplots.par -t '$mc_program estimated translations (mm)' -u 1 --start=4 --finish=6 -a x,y,z -w 800 -h 300 -o trans.png"

    #cleanup files generated for plots (save mcplots.par)
    #old approach, which only keep motion parameters, not RMS.
    #rel "ls -d mcplots* | grep -v mcplots.par | xargs rm -rf"
    #remove the motion-correction 1) NIFTI 2) mean abs RMS 3) mean rel RMS 4) transformation matrices
    #this should retain the abs and rel RMS vectors and the mcplots.par, which contains motion estimates
    #rel "rm -rf mcplots.nii.gz mcplots_abs_mean.rms mcplots_rel_mean.rms mcplots.mat"
    [ -d mcOrig ] && rm -r mcOrig
    mkdir mcOrig
    [ $mc_program = "mcflirt" ] && rel "mv mcplots.nii.gz mcplots_abs_mean.rms mcplots_rel_mean.rms mcplots.mat mcOrig"
    [ $mc_program = "3dvolreg" ] && rel "mv mcplots.nii.gz mcOrig"

    rel "date > .motion_plots_complete"
fi

#optional despiking - first step
if [[ ${despike} = [Yy] ]]; then
    prefix="d_"

    if [ ! -f ".despike_complete" ]; then
	rel "3dDespike -overwrite -cut $despikeThresh -prefix \"${prefix}${funcNifti}\" \"${funcNifti}\""
	rel "date > .despike_complete"
    fi
fi

################################################################################
# functions for preprocessing
################################################################################


function runSliceTimingCorrection {
    #SLICE TIMING CORRECTION

    #file naming changes depending on motion vs. slice timing first
    #problem arises with adding initial _ to prefix of funcFile
    if [ -z ${prefix} ]; then
	infile="${funcFile}"
	prefix="t_"
	outfile="${prefix}${funcFile}"
    else
	infile="${prefix}${funcFile}"
	prefix="t${prefix}"
	outfile="${prefix}${funcFile}"
    fi

    if [ ! -f ".slice_timing_complete" ]; then

        #####
        #Slice timing correction. Note that the conventional wisdom is to apply
	#slice timing correction before motion correction for interleaved acquisition,
        #but after motion correction for sequential acquisition.

        #For interleaved data, slice timing is performed on the original 4D file: -i ${funcFile}
	#For sequential data, slice timing is performed on the motion-corrected 4D file: -i m_${funcFile}
        #Slice timed functionals are output to t_$funcFile: -o "${prefix}${funcFile}"
        #TR is specified by -r
        #--odd specifies interleaved order
	#--down specifies sequential descending
        #--ocustom filename of single-column custom interleave order file (first slice is referred to as 1 not 0)
	#slicetimer default is ascending, so no need to create acquitionString for this setting

	rel "Running slice timing correction" c

	acquisitionString=
	if [ $sliceAcquisition = interleaved ]; then

            # if slice number is even and triotrim is set 
            # need to create a custom slice order file
            # put all even slices first, then all odd slices (where slices are numbered 1..n, bottom-up)
            # use this file with --ocustom switch option to slicetimer
            if [ $((($detectSliceNum%2))) = 0 ] && [ $detectTrioTim -eq 1 ]; then

		rel "  Siemens Trio Tim scanner with even number of slices detected" c
		rel "  Using custom slice order file --ocustom with order 2,4,6...1,3,5..." c
		
		acqCustFile='.triotim_evenSliceNum_acquisitionOrder'
                #Create custom interleaved acquisition order file: evens, then odds
                # print evens(%2==0), then print odds (%2==1)
                n=$detectSliceNum \
                 perl -le '$,="\n"; @a=1..$ENV{n}; for $i (0,1){ print grep {$_%2==$i} @a }' > $acqCustFile
		
		acquisitionString="--ocustom=$acqCustFile"
		
            else
		acquisitionString="--odd"
            fi
	elif [ $sliceAcquisition = seqdesc ]; then
	    acquisitionString="--down"
	fi

	rel "slicetimer -i \"${infile}\" -o \"${outfile}\" -r $tr ${acquisitionString}"

	rel "date > .slice_timing_complete"
    fi
}


# preMC denotes the EPI data before motion realignment. This is needed for one-step fieldmap unwarping and motion correction
# where the motion correction matrices and fieldmap unwarping are applied at once.
# preMC needs to be global: runFieldMapUnwarp needs to see it
preMC=

#mcMats is directory that contains 12-parameter affine matrices to be used in motion + fieldmap interpolation
mcMats=
function runMotionCorrection {
    #MOTION CORRECTION

    #file naming changes depending on motion vs. slice timing first
    #problem arises with adding initial _ to prefix of funcFile
    if [ -z ${prefix} ]; then
	infile="${funcFile}"
	prefix="m_"
	outfile="${prefix}${funcFile}"
    else
	infile="${prefix}${funcFile}"
	prefix="m${prefix}"
	outfile="${prefix}${funcFile}"
    fi


    preMC=$infile #infile is the data before motion correction
    mcMats=mc/$outfile.mat # 12-param affine mat directory (created below, or already created)

    if [ ! -f ".motion_correction_complete" ]; then

        #####
        #Motion correction.
        #Defaults to mean volume correction unless -refvol passed.
        #input: slice-time-corrected 4D file
        #output: motion-corrected, slice-time-corrected 4D file.
        # 
        # if FM unwarping
        #   * example_func
        #   * mc/*{par,rms,mat}
        # 

	rel "Running motion correction" c
	#for now, a slightly junky if else for 3dvolreg versus mcflirt
	if [ $mc_program = "3dvolreg" ]; then
	    if [ -z "$ref_vol" ]; then
		rel "Using mean volume of motion-corrected functional as registration reference for $infile" c

		#have to run motion correction twice to get a reasonable motion-corrected mean volume
		#cf. http://fcp-indi.github.io/docs/developer/workflows/func_preproc.html
		#first run: coregister to mean functional of pre-motion-corrected data (hence, mean could be a bit blurry)
		rel "3dTstat -mean -prefix premc_mean_vol.nii.gz \"${infile}.nii.gz\""
		rel "3dvolreg -Fourier -twopass -base premc_mean_vol.nii.gz -zpad 4 -prefix mc_initial.nii.gz \"${infile}.nii.gz\""
		
		#second run: now take the mean of the corrected series and use that as the coregistration target
		rel "3dTstat -mean -prefix mc_mean_vol_target.nii.gz mc_initial.nii.gz"
		rel "3dvolreg -Fourier -twopass -base mc_mean_vol_target.nii.gz -zpad 4 -prefix \"${outfile}.nii.gz\" \"${infile}.nii.gz\""
		
	    else

		rel "3dvolreg -Fourier -twopass -base $ref_vol -zpad 4 -prefix \"${outfile}.nii.gz\" \"${infile}.nii.gz\""
	    fi
	else
	    #mcflirt
            # need rms these for field mapping
            additionalParams=
            [ -n "$fm_phase" ] && additionalParams="-mats -plots -rmsrel -rmsabs"

            #if no reference volume specified, correct to the mean volume
	    if [ -z "$ref_vol" ]; then
		rel "Using mean volume of motion-corrected functional as registration reference for $infile" c
		rel "fslmaths mcOrig/mcplots -Tmean example_func"
		rel "mcflirt -in \"${infile}\" -o \"${outfile}\" -reffile example_func ${mcflirtSinc} $additionalParams"

	    # using a reference volume
	    else
		if [ -n "${fm_phase}" ]; then
		    rel "extract reference ($ref_vol) as an example of the functional set (for FM unwarp)" c
		    rel  "fslroi $infile example_func $ref_vol 1"
		fi
		rel "Using volume number: $ref_vol for motion correction" c
		rel "mcflirt -in "${infile}" -o "${outfile}" -refvol $ref_vol ${mcflirtSinc} $additionalParams"
	    fi
        fi
        # move extra stuff to mc 
        # if we've created it for fieldmap
        [ -n "$fm_phase" ] && mkdir mc && mv $prefix*{rms,par,mat/} $_ 
	rel "date > .motion_correction_complete"
    fi
}

function runFieldMapUnwarp {
   # unwarp FieldMap
   # prefix: u    -- hardcoded in immv and prefix= below
   if [[ -n "${fm_phase}" && ! -f ".unwarp_complete" ]]; then
       
       #expect:
       #  example_func has been created 
       #  have motion corrected functional
       # -fm_phase
       # -fm_magnitude
       # -fm_cfg

       [ ! -r example_func.nii* ] && echo "cannot find example_func (created during motion correction)!" && exit 1
       
       rel "Applying fieldmap" c

       if [ $cleanup -eq 1 ]; then savetemps=no; pics=no;
       else savetemps=yes; pics=yes;
       fi
     
       rel "logFile=$logFile savetemps=$savetemps pics=$pics \
        $(dirname $0)/preprocessFMUnwarp -m $fm_magnitude -p $fm_phase -c $fm_cfg --preMC $preMC --mcMats $mcMats"

       # creates unwarp_thumbnails dirctory
       # leaves prefiltered_func_data_unwarp.nii

       rel "immv prefiltered_func_data_unwarp.nii u$prefix$funcFile"

       rel "date > .unwarp_complete"

       # record actions in nii files
       # addNote $prefix$funcFile  \
       #   "$(dirname $0)/preprocessFMUnwarp -f $prefix$funcFile -m $fm_magnitude -g $fm_phase -c $fm_cfg"

   fi

   # set prefix to include unwarping given we did this
   [ -n "${fm_phase}" ] && prefix="u$prefix" 

   # if above fails, we return from function with error exit code and script exits (b/c set -e)
   return 0
}

#betBrain is global
betBrain=
function runSkullStrip {
   #SKULL STRIPPING
   if [ ! -f ".skull_strip_complete" ]; then
       #####
       #Compute the mean functional: mt_mean_func.nii.gz
       #Used in warping subjects mean T2* to his/her T1 structural scan

       rel "4. Computing mean functional" c
       rel "fslmaths \"${prefix}${funcFile}\" -Tmean \"${prefix}mean_func\""

       #####
       #Skull strip the mean functional: kmt_mean_func.nii.gz

       rel "5. Skull stripping functionals" c
       rel "bet \"${prefix}mean_func\" \"k${prefix}mean_func\" -R -f ${betFrac} -m"

       #Use the mask generated from skull stripping the mean functional to strip all functionals
       rel "fslmaths \"${prefix}${funcFile}\" -mas \"k${prefix}mean_func_mask\" \"k${prefix}${funcFile}\""

       #old approach commented out below.
       #used to run -F separately on 4d functionals, which runs bet with 0.3 on first volume of 4d, dilates mask
       #new approach is to use mask from betting mean functional, which coincides better with FEAT and allows
       #greater control of skull stripping using -bet_frac
       #####
       #Skull strip the 4D functional file: kmt_$funcFile
       #-F strips each functional using -f 0.3 with slight dilation of brain mask
       #note that -F also generates a mask file: kmt_$funcFile_mask.nii.gz (this is never used, I think)
       #
       #bet "${prefix}${funcFile}" "k${prefix}${funcFile}" -F

       rel "date > .skull_strip_complete"

   fi

   #store the pre-bet file for application of combined BET + intensity mask below
   preBet="${prefix}${funcFile}"
   prefix="k${prefix}"
}



################################################################################
# EPI 
################################################################################

#determine precedence of slice timing and motion correction
#if sequential, then 1) motion correct, 2) slice timing correct
#if interleaved, then 1) slice timing correct, 2) motion correct

# NOTE: Jesper Andersson <jesper@fmrib.ox.ac.uk> (FSL mailing list)
# In short: The correct thing is to do a 4D interpolation, but that is practically cumbersome. 
# When doing them sequentially you start with the one that introduces the biggest variance/error,
# and that is definitely movement.
# My suggestion is 1) Movement+fieldmap 2) Slice timing.


#Option 1: 4-D slice timing + motion correction
if [ $sliceMotion4D -eq 1 ]; then
    if [ -z ${prefix} ]; then
	infile="${funcNifti}"
	prefix="tm_"
	slcmotprefix="tm_" #sliceMotion4D prepends a prefix onto existing input
    else
	infile="${prefix}${funcNifti}"
	prefix="tm${prefix}"
	slcmotprefix="tm"
    fi

    #have to translate the nomenclature...
    if [ -n "${sliceTimesFile}" ]; then
	[ ! -r "${sliceTimesFile}" ] && echo "Unable to load -custom_slice_times ${sliceTimesFile}" && exit 1
	slcorder="${sliceTimesFile}"
    elif [ $sliceAcquisition = "seqdesc" ]; then
	slcorder="descending"
    elif [ $sliceAcquisition = "seqasc" ]; then
	slcorder="ascending"
    elif [ $sliceAcquisition = "interleaved" ]; then
	slcorder="interleaved"
    fi

    rel "python2 $(which sliceMotion4d) --inputs \"${infile}\" --tr $tr --slice_times $slcorder --prefix ${slcmotprefix}"
    rel "date > .motion_correction_complete"
    rel "date > .slice_timing_complete"

elif [[ $no_st -eq 1 ]]; then
    #just motion and FM unwarp
    runMotionCorrection
    runFieldMapUnwarp    
elif [[ $sliceAcquisition = interleaved || $st_first -eq 1 ]]; then	
    runSliceTimingCorrection
    runMotionCorrection
    runFieldMapUnwarp
elif [[ $sliceAcquisition = "seqasc" || $sliceAcquisition = "seqdesc" || $mc_first -eq 1 ]]; then
    runMotionCorrection
    runFieldMapUnwarp
    runSliceTimingCorrection
fi

#Skull strip EPI
runSkullStrip


#THRESHOLDING LOW INTENSITY VOXELS
if [[ ! -f ".thresholding_complete" && $thresholdMethod = "10" ]]; then
    rel "Thresholding 4d functionals by masking any voxel below the 10th percentile \(distribution is non-zero voxels\)." c

    #####
    #calculate the 10th percentile of non-zero voxels
    #input: slice-timed, motion-corrected, skull-stripped 4D functionals

    P_10=$( fslstats "${prefix}${funcFile}" -P 10 )

    #####
    #for each voxel, calculate the minimum activation value for the
    #run (i.e., over time) and create a single volume with all minima.
    #output: kmt_$funcFile_Tmin.nii.gz
    rel "fslmaths \"${prefix}${funcFile}\" -Tmin \"${prefix}${funcFile}_Tmin\""

    #####
    #Threshold the minimum activation volume by zeroing all values below the
    #10th percentile in the 4D file.
    #input: single volume with minimum activation values over the run: kmt_$funcFile_Tmin.nii.gz
    #output: single volume with minimum activation values over the run, with any value < 10th percentile set to 0: kmt_$funcFile_Tmin_10pctThr.nii.gz

    rel "fslmaths \"${prefix}${funcFile}_Tmin\" -thr $P_10 \"${prefix}${funcFile}_Tmin_10pctThr\""

    #####
    #Create a binary mask from the thresholded minimum activation volume,
    #where any non-zero value receives a value of 1 in the mask, and any 0 value
    #is 0 in the mask. Essentially, any
    #voxel that was below the 10th percentile in the original data will be zeroed.
    #output: mask_$funcFile_Tmin_10pctThr.nii.gz

    rel "fslmaths \"${prefix}${funcFile}_Tmin_10pctThr\" -bin \"mask_${funcFile}_Tmin_10pctThr\" -odt char"

    #####
    #Mask the slice-timed, motion-corrected, skull-stripped 4D functionals
    #file using the mask created above.
    #output: slice-timed, motion-corrected, skull-stripped, 10th percentile thresholded 4D file: kmt_$funcFile_masked.nii.gz

    rel "fslmaths \"${prefix}${funcFile}\" -mas \"mask_${funcFile}_Tmin_10pctThr\" \"${prefix}${funcFile}_masked\""

    threshMask="mask_${funcFile}_Tmin_10pctThr"

    rel "date > .thresholding_complete"

elif [[ ((! -f ".thresholding_complete") && $thresholdMethod = "98_2") || $smoother = "susan" || $rescalingMethod = "10000_globalmedian" ]]; then

    p_2=$( fslstats "${prefix}${funcFile}" -p 2 )
    p_98=$( fslstats "${prefix}${funcFile}" -p 98 )

    #note that this threshold calculation is based on FEAT's brain/background threshold of 10
    #the FEAT calculation is p2 + (brain_thresh * (p98 -p2))/100. When brain_thresh is 10, cancels a zero.
    thresh=$( echo "scale=5; $p_2 + ($p_98 - $p_2)/10" | bc )

    #create mask that zeroes anything below threshold.
    #because this mask is computed on the skull-stripped data, it also reflects skull stripping
    rel "fslmaths \"${prefix}${funcFile}\" -thr $thresh -Tmin -bin \"${prefix}${funcFile}_98_2_mask\" -odt char"

    #calculate median intensity (after dumping thresholded voxels) -- compute this prior to dilation to avoid inclusion of 0 voxels
    #Echoing the FEAT approach, compute this on pre-bet data, with mask applied. Should have little or no effect since the mask 
    #effectively does BET since it was generated from post-BET data.
    median_intensity=$( fslstats "${preBet}" -k "${prefix}${funcFile}_98_2_mask" -p 50 )

    #dilate mask (drawing from FEAT). This creates a liberal mask unlikely to delete brain voxels
    #Logic and dilF command not well documented in FSL.
    rel "fslmaths \"${prefix}${funcFile}_98_2_mask\" -dilF \"${prefix}${funcFile}_98_2_mask_dil1x\""

    #susan requires the 2nd pctile and the median intensity to auto-calculate brightness threshold
    #but if 98_2 thresholding requested, then actually apply the resulting mask
    if [[ $thresholdMethod = "98_2" && ! -f ".thresholding_complete" ]]; then
	rel "Thresholding 4d functionals by zeroing any voxel below the value: 2nd %ile + \(98th %ile - 2nd %ile\)/10" c
	rel "This is the default thresholding method used by FSL GUI tools." c

	#Apr2012: Following FEAT, apply the mask to pre-BET data. The logic is that BET may cut out too much brain.
	#We have generated a mask that reflects: 1) Skull strip; 2) removal of low intensity; 3) 1x mask dilation
	#If we were to apply this mask to post-BET data, the 1x dilation would essentially be irrelevant since BET would 
	#have already zeroed those data.
	rel "fslmaths \"${preBet}\" -mas \"${prefix}${funcFile}_98_2_mask_dil1x\" \"${prefix}${funcFile}_masked\""
	
	rel "date > .thresholding_complete"
    fi

    threshMask="${prefix}${funcFile}_98_2_mask_dil1x"

fi

#ALIGN FUNCTIONAL AND STRUCTURAL, WARP TO TEMPLATE SPACE
if [[ ! -f ".warp_complete" && $no_warp -eq 0 ]]; then
    #####
    #Obtain a transformation matrix that co-registers the subject's
    #structural T1 scan with his/her mean functional T2* image.

    #note that I changed the dof setting for flirt to 7, which is a rigid body
    #transformation (6 df) with 1 additional df allowing for global rescaling.
    #the default is 12df, which is affine, but this isn't appropriate for
    #images from the same person.

    #as currently written, this creates a warped functional (perhaps important
    #for checking the success of the warp), but the important part is the
    #transformation matrix: func_to_mprage.mat

    #weight registration by signal quality from fieldmap, if available
    inweight=
    [ -n "${fm_phase}" ] && inweight="-inweight $(pwd)/unwarptemps/EF_UD_fmap_sigloss"

    rel "6. Warping subject mean functional to subject structural (intrasubject)" c

    if [ $funcStructFlirtDOF = "bbr" ]; then

	mprageBet_base=$( remove_ext ${mprageBet} )
	flirtVersion=$( flirt | head -1 | perl -pe 's/^FLIRT version ([0-9\\.]+)$/\1/' )
	if [ $( echo "${flirtVersion} >= 6" | bc ) -eq 1 ]; then
	    rel "Using boundary-based registration approach to register EPI to T1" c
	    [ $( imtest "${mprageBet_base}_fast_seg" ) -eq 0 ] && rel "fast -o \"${mprageBet_base}_fast\" \"${mprageBet_base}\"" #segment T1 to create WM
	    [ $( imtest "${mprageBet_base}_fast_wmseg" ) -eq 0 ] && rel "fslmaths ${mprageBet_base}_fast_pve_2 -thr 0.5 -bin ${mprageBet_base}_fast_wmseg" #create binary WM mask
	    
	    #standard 6 parameter EPI-to-T1 registration to get initial estimate of transform
	    rel "flirt -in \"${prefix}mean_func\" -ref $mprageBet -out func_to_mprage -omat func_to_mprage_init.mat -dof 6" #leaving off inweight for now because should handle fieldmap in flirt now

	    #now do the BBR-based registration
            #N.B.: the epi_reg program uses betted T1 for initial transformation, but the unbetted image for BBR registration!
	    rel "flirt -in \"${prefix}mean_func\" -ref $mprageBet -out func_to_mprage -omat func_to_mprage.mat -wmseg ${mprageBet_base}_fast_wmseg -cost bbr -init func_to_mprage_init.mat -dof 6 -schedule ${FSLDIR}/etc/flirtsch/bbr.sch"
	else
	    rel "BBR EPI-to-T1 requested, but flirt < v6.0. Reverting to typical 7 DOF registration" c
	    funcStructFlirtDOF=7
	    rel "flirt -in \"${prefix}mean_func\" -ref $mprageBet -out func_to_mprage -omat func_to_mprage.mat -dof $funcStructFlirtDOF $inweight"
	fi
    else
	rel "flirt -in \"${prefix}mean_func\" -ref $mprageBet -out func_to_mprage -omat func_to_mprage.mat -dof $funcStructFlirtDOF $inweight"
    fi

    #####
    #Warp all T2* functionals to standard space (sampled at 3mm isotropic)
    #input: slice-timed, motion-corrected, skull-stripped, thresholded
    #  4D functionals: kmt_$funcFile 
    #output: 4D functionals file warped to Talairach space, resampled to
    #  3mm isotropic voxels: wkmt_$funcFile

    #note that I switched over to sinc interpolation, which is slowest, but best.
    #applywarp defaults to trilinear, which blurs the image.

    #--ref: Reference brain. Note that the dimensions and voxel sizes of the
    #  ref parameter become the dimensions and voxel sizes for the resulting
    #  images.
    #--in: The input is the slice-timed, motion-corrected, skull-stripped,
    #  thresholded 4D functional file: kmt_$funcFile_masked.
    #--out: The warped 4D functionals file to create: wkmt_$funcFile
    #--premat: An affine (linear) transformation matrix to be applied to
    #  each volume prior to the nonlinear warp. This is important so that
    #  each functional volume is first spatially aligned with the structural
    # scan before being warped.
    #--warp: The warping matrix to be applied. Here, we use the nonlinear
    #  warping matrix from the mprage normalization.
    #--interp: The interpolation method for performing the warp. See -warp_interpolation in help.
    #--mask: Restrict the warp to the mask above used for thresholding low intensity voxels.
    #  Note that this corrects odd behavior with applywarp and sinc interpolation smudging edge voxels extensively.
    #  See here: https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1108&L=FSL&P=R66855&1=FSL&9=A

    #transform threshold / skull strip mask from prior step into template space. Could this be done with one applywarp and a premat?
    rel "flirt -in ${threshMask} -applyxfm -init func_to_mprage.mat -out ${threshMask}_lin -paddingsize 0.0 -interp nearestneighbour -ref $mprageBet"
    rel "applywarp --ref=${templateBrain} --out=w${threshMask} --interp=nn --in=${threshMask}_lin --warp=${warpCoef}"

#This is an example of the one-step version. Quick visual inspection suggestions that the one-step is slightly eroded relative to the linear + nonlinear
#Whether this matters at all is unclear. Still, keep as two steps for now.
# applywarp \
# 	--ref=$HOME/standard/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_3mm.nii  \
# 	--in=kmt_functional_98_2_mask.nii.gz \
# 	--out="testlin_onestep" \
# 	--premat=func_to_mprage.mat \
# 	--warp=../../anatomical/mprage_warpcoef.nii.gz \
# 	--interp=nn

    #warning: sinc interpolation is most precise, but if the mask used below does not precisely match the subject's
    #structural scan (e.g., greater cerebellar coverage for anat relative to functional), then sinc is prone to extending
    #the warp into non-brain space in ways that produce artifact. Spline is the more intelligent default unless you
    #have precisely setup the mask.

    #12Jul2012: constrain_to_template: shrink functional mask for warping to be no bigger than the anatomical mask
    #to ensure that subject mask does not extend beyond anatomical borders, since this could lead to weird stretching etc.
    #The risk may have to do with applywarp doing excessive padding, especially for sinc:
    #https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1108&L=FSL&P=R69770
    #The risk may also a difference in coverage/size between MPRAGE and EPI because warp coefficients are generate for MPRAGE,
    #but applied here to EPI.
    #Also, this step eliminates brain activation that falls outside of the template mask
    #So, in general, this is a good idea, hence default yes.

    if [[ $constrainToTemplate = [Yy] ]]; then

	#Generate template anatomical mask (these are in ~/standard already, but are created by resampling stock brain mask).
	#The template mask created here will tend to be slightly bigger than the warped mask in ~/standard
	#because of small floating point values around T1 template. Still, using the 10th percentile of non-zero voxels
	#as an initial threshold seems to reduce differences to trivial amounts.
	#And eyeballing the mask versus T1, the ~/standard warped mask file may lose some voxels of interest.

	#zero anything below 10th percentile of non-zero voxels, then binarize
	rel "fslmaths ${templateBrain} -thrP 10 -bin templateMask -odt char"

        #subtract template anatomical mask from subject's mask, then threshold at zero
	#(neg values represent areas where anat mask > subj mask, which are not of interest)
	#thus, subject mask may be smaller than template (e.g., low cerebellum coverage), but not bigger.
	rel "fslmaths w${threshMask} -sub templateMask -thr 0 w${threshMask}_outOfAnatBounds -odt char"
	
	#subtract the out of bounds mask from subject mask (trim to match template)
	rel "fslmaths w${threshMask} -sub w${threshMask}_outOfAnatBounds w${threshMask}_templateTrim -odt char"

	subjMask=w${threshMask}_templateTrim
	[ $cleanup -eq 1 ] && deleteFile "w${threshMask}.nii.gz"
    else
	subjMask=w${threshMask}
    fi

    rel "7. Warping functionals to standard space using coefficients from structural nonlinear warp. Creating functionals with 3mm isotropic voxels" c
    rel "applywarp \
	--ref=$templateBrain \
	--in=\"${prefix}${funcFile}_masked\" \
	--out=\"w${prefix}${funcFile}\" \
	--premat=func_to_mprage.mat \
	--warp=${warpCoef} \
	--interp=${funcWarpInterp} \
	--mask=${subjMask}"

    #add symbolic link of template used to the directory to document which template file was used
    if [[ -f "${templateBrain}.nii" && ! -h ./template_brain.nii ]]; then
	rel "ln -sfn \"${templateBrain}.nii\" ./template_brain.nii"
    elif [[ -f "${templateBrain}.nii.gz" && ! -h ./template_brain.nii.gz ]]; then
	rel "ln -sfn \"${templateBrain}.nii.gz\" ./template_brain.nii.gz"
    fi

    rel "date > .warp_complete"
fi

#only add w prefix if warp is part of the pipeline
if [ $no_warp -eq 0 ]; then
    prefix="w${prefix}"

    #don't keep the unwarped mask
    [ $cleanup -eq 1 ] && deleteFile "${threshMask}.nii.gz"
else
    subjMask=${threshMask} #subject mask is just non-warped threshold mask
fi

#Create an extents mask post-warp that ensures that all unsmoothed voxels are sampled at all timepoints. 
#Then apply mask after smoothing to ensure well-behaved voxels (i.e., not smoothing a mixture of zero and non-zero voxels).
rel "fslmaths ${prefix}${funcFile} -Tmin -bin ${prefix}${funcFile}_extents_mask -odt char"

extentsMask=${prefix}${funcFile}_extents_mask

if [[ ! -f ".smoothing_complete" && $no_smooth -eq 0 ]]; then

    rel "8. Smoothing functional data" c

    if [ $smoother = "susan" ]; then
	dimensionality=3 #smooth in two or three dimensions
	susan_thresh=$( echo "scale=5; ($median_intensity - $p_2) * 0.75" | bc )
    
        #recompute mean functional, which is used for susan
	rel "fslmaths \"${prefix}${funcFile}\" -Tmean \"${prefix}mean_func\""
	rel "susan \"${prefix}${funcFile}\" $susan_thresh $sigma $dimensionality 1 1 \"${prefix}mean_func\" $susan_thresh \"s${prefix}${funcFile}${smoothing_suffix}\""
	
	rel "date > .smoothing_complete"

    elif [ $smoother = "gaussian" ]; then

        #By dumb luck, I stumbled across a paper on correcting edge artifact due to gaussian smoothing:
        #Maisog and Chmielowska (1998). It turns out that Robert's method below implements their recommendations!
        #The procedure is:
        #1) Define a binary mask denoting the voxels to be analyzed (i.e., all brain voxels in, all non-brain out).
        #2) For safety, apply this mask to the 4d file. (Shouldn't have an impact)
        #3) Blur the binary mask using the same Gaussian kernel to be used for smoothing. This results
        #   in a "weighting" volume that has correction factors for voxels toward the edge.
        #   Essentially, any edge voxel will have a correction factor < 1, which represents degree of falloff due to blurring
        #   with non-brain near-zero voxels.
        #4) Apply Gaussian smoothing to the 4d file, dividing the result by the correction volume, thereby correcting for falloff.
	
        #####
        #Create a binary mask, mask_pre.nii.gz, that is zero for all zero voxels and 1 for any non-zero
        #voxel (i.e., in vs. out).
	
        #This is essentially just taking the Tmin of the image.
        #The max 0 says "take the minimum activation or 0, whichever is greater"
        #Would handle a weird circumstance where an activation was < 0.
        #But I just diffed the files with and without -max 0 and they are identical.
	
        #This is then used to build a "weighting" mask that handles edge falloff.
	
	rel "fslmaths \"${prefix}${funcFile}\" -max 0 -Tmin -bin \"${prefix}mask_allbrain\" -odt char"
	
        #####
        #Apply the mask from prior step to the warped functionals.
        #(note that input and output are the same). This seems more like a safety procedure,
        #applying a mask that was generated to be 0 v. non-0 should have no effect.
	
	rel "fslmaths \"${prefix}${funcFile}\" -mas \"${prefix}mask_allbrain\" \"${prefix}${funcFile}\""
        #NOTE THAT I JUST TOOK OUT THE ABOVE STEP DIFFED THE FILES.... NO DIFFERENCE. Superfluous (except I guess with negative values)
	
        #####
        #Blur the in v. out mask using the same sigma for subsequent smoothing.
        #For the vast majority of the brain, the weight will be 1 (because blurring a 1 with many other 1s is 1).
        #But toward the edge, there will be falloff as brain and non-brain voxels are mixed.
        #Thus, at the edges, the weight will drop toward 0.
        #output: mask_weight.nii.gz
	
        #-odt float is important to retain continuous values
	rel "fslmaths \"${prefix}mask_allbrain\" -s $sigma \"${prefix}mask_edgecorrection\" -odt float"
	
        #####
        #Apply gaussian smoothing to the warped 4D functionals file.
        #Not entirely clear on the approach here.
	
        #-s $sigma: apply gaussian smoothing (mean filtering) with the specified sigma
        #-div wkmt_mask_edgecorrection: divides the input image (wkmt_$funcFile) by mask_edgecorrection (i.e., apply edge correction)
        #-mas wkmt_mask_allbrain: mask output image to retain only brain/nonzero voxels.
	
        #note that it's okay for the edge correction mask not to be masked because of the -mas parameter here.
	rel "fslmaths \"${prefix}${funcFile}\" -s ${sigma} -div \"${prefix}mask_edgecorrection\" -mas \"${prefix}mask_allbrain\" \"s${prefix}${funcFile}${smoothing_suffix}\""
	
	rel "date > .smoothing_complete"
    fi
fi #end check for smoothing_complete

if [ $no_smooth -eq 0 ]; then
    prefix="s${prefix}"

    #now apply the extents mask to eliminate excessive blurring due to smooth and only retain voxels fully sampled in unsmoothed image
    rel "fslmaths ${prefix}${funcFile}${smoothing_suffix} -mul ${extentsMask} ${prefix}${funcFile}${smoothing_suffix} -odt float"
else
    smoothing_suffix= #clear the suffix since no smoothing performed
fi

if [ ! -f ".temporal_filtering_complete" ]; then

    #####
    #High-pass filtering for slow-frequency scanner drift
    #-bptf 20 -1: pass any signal faster than 20 TRs, don't low-pass filter (-1)

    rel "9. High-pass filtering functional data" c
    rel "fslmaths \"${prefix}${funcFile}${smoothing_suffix}\" -bptf $hpFilter -1 \"f${prefix}${funcFile}${smoothing_suffix}\""

    rel "date > .temporal_filtering_complete"

fi
prefix="f${prefix}"


if [ ! -f ".rescaling_complete" ]; then
    #####
    #Compute a mean functional volume after all of the preprocessing
    #steps are complete. This image has been slice-timed, motion-corrected,
    #skull-stripped, warped to Talairach, smoothed, and high-pass filtered.

    rel "10. Grand mean intensity normalization (rescaling)" c
    
    if [ $rescalingMethod = "10000_globalmedian" ]; then
	rel "Rescaling intensities by a single factor: 10000/globalmedian" c
	rescalingFactor=$( echo "scale=5; 10000/${median_intensity}" | bc )
	rel "fslmaths \"${prefix}${funcFile}${smoothing_suffix}\" -mul $rescalingFactor \"n${prefix}${funcFile}${smoothing_suffix}\" -odt float"
    elif [ $rescalingMethod = "100_voxelmean" ]; then
        #####
        #Rescale the 4D functionals file by dividing activations in each
        #volume by the mean_float volume from Step 19 above and multiplying by 100.
        #This is considered "grand mean scaling" (as opposed to global rescaling),
        #which is important for cross-subject/cross-session inferences
        #to be valid (i.e., on a similar scale).

	rel "Rescaling intensities by 100/voxelmean" c

	rel "fslmaths \"${prefix}${funcFile}${smoothing_suffix}\" -Tmean \"${prefix}mean_float\" -odt float"
	rel "fslmaths \"${prefix}${funcFile}${smoothing_suffix}\" -mul 100 -div ${prefix}mean_float \"n${prefix}${funcFile}${smoothing_suffix}\" -odt float"
    fi

    rel "date > .rescaling_complete"
fi

prefix="n${prefix}"

#####
#Ensure that the resulting 4D NIFTI file has the correct TR. (history of FSL stripping this information out)

rel "11. Setting TR in ${prefix}${funcFile}${smoothing_suffix}.nii.gz to: $tr" c
rel "3drefit -TR $tr \"${prefix}${funcFile}${smoothing_suffix}.nii.gz\""

#####
#Compute mean functional of final 4d file and mask to be used in GLM
#First mask the final preprocessed file using the warped mask from above.

#probably not totally necessary, but seems like an important last check to ensure that no blurring has occurred.
#extents mask above, in principle, should help with this.
rel "fslmaths \"${prefix}${funcFile}${smoothing_suffix}\" -mas ${subjMask} \"${prefix}${funcFile}${smoothing_suffix}\""
rel "fslmaths \"${prefix}${funcFile}${smoothing_suffix}\" -Tmean \"${prefix}mean_func${smoothing_suffix}\""

#if mask file exists, and subject_mask.nii is not a file (but could be a symlink), then create subject_mask symlink
if [[ -f "${subjMask}.nii"  && ! -f ./subject_mask.nii ]]; then
    rel "ln -sfn \"${subjMask}.nii\" ./subject_mask.nii"
elif [[ -f "${subjMask}.nii.gz" && ! -f ./subject_mask.nii.gz ]]; then
    rel "ln -sfn \"${subjMask}.nii.gz\" ./subject_mask.nii.gz"
fi

# 9/27/2011: note that with sinc interpolation, there tend to be some small negative values ringing the brain post-smoothing
# with an outer ring of even tinier positive values. When binarizing this, it results in a bizarre mask with an asteroid belt of sorts.
# The sensible solution is to use the mask from the thresholding step, which represents the brain voxels retained after skull stripping and
# intensity thresholding. In the warping step, I use that to mask the functional output. Need to use the same mask again here
# to mask the final file that has been smoothed. Computing a mask after all steps have finished, as I had earlier, makes little sense.
# we don't want smoothing, temporal filtering, or rescaling to influence what constitutes a brain voxel.

#Cleanup files, if requested
if [ $cleanup -eq 1 ]; then

    if [[ ${despike} = [Yy] ]]; then
	dspre="d"
	deleteFile d_${funcNifti}
    else
	dspre=""
    fi

    if [ $no_warp -eq 0 ]; then
	wpre="w"
    else
	wpre=""
    fi

    if [ -n "${fm_phase}" ]; then
	upre="u"
    else
	upre=""
    fi

    #interleaved stream
    deleteFile t${dspre}_${funcFile}.nii.gz
    deleteFile mt${dspre}_${funcFile}.nii.gz
    deleteFile ${upre}mt${dspre}_${funcFile}.nii.gz
    deleteFile ${upre}mt${dspre}_${funcFile}_mean_reg.nii.gz
    deleteFile k${upre}mt${dspre}_${funcFile}.nii.gz
    deleteFile k${upre}mt${dspre}_mean_func_mask.nii.gz
    deleteFile ${wpre}k${upre}mt${dspre}_${funcFile}.nii.gz
    deleteFile ${wpre}k${upre}mt${dspre}_${funcFile}_extents_mask.nii.gz
    deleteFile s${wpre}k${upre}mt${dspre}_${funcFile}${smoothing_suffix}.nii.gz
    deleteFile fs${wpre}k${upre}mt${dspre}_${funcFile}${smoothing_suffix}.nii.gz

    deleteFile k${upre}mt${dspre}_${funcFile}_Tmin.nii.gz
    deleteFile k${upre}mt${dspre}_${funcFile}_Tmin_10pctThr.nii.gz
    deleteFile ${upre}mt${dspre}_mean_func.nii.gz
    deleteFile k${upre}mt${dspre}_mean_func.nii.gz
    deleteFile ${wpre}k${upre}mt${dspre}_mean_func.nii.gz
    deleteFile fs${wpre}k${upre}mt${dspre}_mean_float.nii.gz
    deleteFile k${upre}mt${dspre}_${funcFile}_98_2_mask.nii.gz
    deleteFile k${upre}mt${dspre}_${funcFile}_masked.nii.gz
    deleteFile s${wpre}k${upre}mt${dspre}_${funcFile}${smoothing_suffix}_usan_size.nii.gz

    #sequential stream
    deleteFile m${dspre}_${funcFile}.nii.gz
    deleteFile m${dspre}_${funcFile}_mean_reg.nii.gz
    deleteFile ${upre}m${dspre}_${funcFile}.nii.gz
    deleteFile t${upre}m${dspre}_${funcFile}.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}.nii.gz
    deleteFile kt${upre}m${dspre}_mean_func_mask.nii.gz
    deleteFile ${wpre}kt${upre}m${dspre}_${funcFile}.nii.gz
    deleteFile ${wpre}kt${upre}m${dspre}_${funcFile}_extents_mask.nii.gz
    deleteFile s${wpre}kt${upre}m${dspre}_${funcFile}${smoothing_suffix}.nii.gz
    deleteFile fs${wpre}kt${upre}m${dspre}_${funcFile}${smoothing_suffix}.nii.gz

    deleteFile kt${upre}m${dspre}_${funcFile}_Tmin.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}_Tmin_10pctThr.nii.gz
    deleteFile t${upre}m${dspre}_mean_func.nii.gz
    deleteFile kt${upre}m${dspre}_mean_func.nii.gz
    deleteFile ${wpre}kt${upre}m${dspre}_mean_func.nii.gz
    deleteFile fs${wpre}kt${upre}m${dspre}_mean_float.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}_98_2_mask.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}_mask.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}_masked.nii.gz
    deleteFile s${wpre}kt${upre}m${dspre}_${funcFile}${smoothing_suffix}_usan_size.nii.gz

    #general files
    deleteFile mc_mean_vol_target.nii.gz
    deleteFile premc_mean_vol.nii.gz
  
    deleteFile func_to_mprage.mat
    deleteFile func_to_mprage.nii.gz

    deleteFile mask_${funcFile}_Tmin_10pctThr.nii.gz

    deleteFile ${prefix}mean_func${smoothing_suffix}.nii.gz
  
    #some more here...
    deleteFile "${threshMask}_lin.nii.gz"
    deleteFile "w${threshMask}_outOfAnatBounds.nii.gz"
    deleteFile templateMask.nii.gz

    rm -rf mcOrig
    rm -rf unwarptemps

    deleteFile example_func.nii.gz

    #TODO
    #deleteFile createdByFMUnwarp
fi


if [[ ${deoblique_all} = [Yy] ]]; then
    allNii=$( ls | grep ".*\.nii\.gz" )

    for nii in ${allNii}; do
	mv "${nii}" "toDeoblique_${nii}"
   
        # Run AFNI's deoblique so that it doesn't complain when looking at oblique datasets
        # Default is linear interpolation (blurry), so upgrade to quintic.
        # Note that this step necessarily resamples and interpolates the data.
	# Thus, in general, I would not recommend it since its main purpose is to quiet AFNI's warning
	3dWarp -deoblique -prefix "${nii}" -quintic "toDeoblique_${nii}"
    
	rm -f  "toDeoblique_${nii}"
    done

fi

## Step 99: write (append) finish time, mv incomplete to complete
echo "# finished $(date $datefmt)" >> ${dotfile}_incomplete
mv ${dotfile}_incomplete ${dotfile}_complete


#The second round of 10th percentile thresholding has been removed as of 19Jul2010.
#This decision was based on comparison with FEAT's pipeline, discussions
#with Katerina and the group, and comparisons of the results with and without
#this step. The thresholding step above should handle elimination of non-brain voxels (post-BET).
#With real data, this thresholding step was typically masking out edge voxels, which seems to offset
#some of the putative gains made by using the edge correction masking above.
#--------COMMENTED OUT----------
#####
#Step 22: Another round of thresholding. Calculate the 10th percentile of
#non-zero voxels from the mean functional image.

#echo "12. Zeroing any activations < 10th percentile"
#P_10=$( fslstats fswkmt_mean_float -P 10 )

#####
#Step 23: Create a binary mask from the mean functional image that zeroes
#anything below the 10th percentile and sets anything else to 1.
#output: mask.nii.gz

#fslmaths fswkmt_mean_float -thr $P_10 -bin mask -odt char

#####
#Step 24: Apply the mask to the mean_float image.
#output: fswkmt_mean_float_masked.nii.gz

#fslmaths fswkmt_mean_float -mas mask fswkmt_mean_float_masked

#####
#Step 25: Apply the Step 23 mask to the final 4D functionals file (nfswkmt_$funcFile_$smoothing_kernel).

#fslmaths "${prefix}${funcFile}${smoothing_suffix}" -mas mask "${prefix}${funcFile}${smoothing_suffix}_wmask"

# if [[ -n ${fm_phase} && ! -f ".unwarp_complete" ]]; then
    
# #what I expect:
#     #-fm_magnitude
#     #-fm_phase
#     #-fm_cfg

#     rel "Applying fieldmap" c
  
#     #https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind0712&L=FSL&P=R35595&1=FSL&9=A&I=-3&J=on&d=No+Match%3BMatch%3BMatches&z=4
#     #so, from Siemens Trio scanner, GRE fieldmaps are (typically) 0-4096. When converted from DICOM, the NIFTI header has
#     #scl_inter=-4096 and scl_slope=2. So add 4096 and divide by 2 to recover original units.
#     #As shown in this post, a one-step conversion of the fieldmap to rad/s can be accomplished like so:

#     #fslmaths rawfieldmap.nii.gz -mul 3.141593 -div 4096 -div .00246 radpers -odt float

#     #or, one could undo the (weird) inter/slope encoding and compute in long-form:
#     #fslmaths grefieldmap2.nii.gz -add 4096 -div 2 -sub 2048 -div 2048 -mul 3.14159 -div .00246 twostep

#     #in our case, just check the fieldmap header to make sure it's -4096 intercept and 2 slope
#     #then proceed with onestep

#     intercept=$( fslhd ${fieldmap}  | grep '^scl_inter' | perl -pe 's/scl_inter\s+(\d+)/\1/' )
#     slope=$( fslhd ${fieldmap}  | grep '^scl_slope' | perl -pe 's/scl_slope\s+(\d+)/\1/' )
    
#     match=$( echo "${intercept} == -4096 && ${slope} == 2" | bc )
   
#     if [ ${match} -ne 1 ]; then
# 	echo -e "Fieldmap intercept and slope fields do not match expected values of -4096 and 2, respectively.\n  Cannot determine conversion to rad/s. Exiting script.\n"
# 	exit 1
#     fi

#     if [ ! -f ${fieldmap} ]; then
# 	echo "Cannot find specified fieldmap input: ${fieldmap}"
# 	exit 1
#     fi

#     if [ -z ${dte} ]; then
# 	echo "Dwell time not specified alongside -fieldmap. Pass in using -dwell_time option. Exiting script."
# 	exit 1
#     fi

#     rel "Convert fieldmap to rad/s." c
#     rel "fslmaths \"${fieldmap}\" -mul 3.141593 -div 4096 -div ${dte} \"${fieldmap}_radpers\" -odt float"

#     rel "Apply median filter to fieldmap." c
#     rel "fugue --loadfmap=\"${fieldmap}_radpers\" -m --savefmap=\"${fieldmap}_radpers\""

#     rel "Apply fieldmap." c
# #    rel "fugue -i \"${prefix}${funcField}\"                       --dwell=0.360
# #                        --loadmap==grefieldmap2.nii.gz
# #                        -u mt_functional_homogeneous.nii.gz
# fi


		#num=$detectSliceNum perl -le \
                #    'for $i (2,1){                      # for all even slices, then all odd slices
                #     $j=-2+$i; 
                #     print $j+=2 while $j<=$ENV{num}-2 # $j+=2 doesnt return as expected in condition context
                #    }' > $acqCustFile
